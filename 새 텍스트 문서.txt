멀티스레드
MMO의 경우 코어를 여러개 써야함. - > 단일 쓰레드로 돌리면 많이 느림.
프로그램 설정에서 스레드몰빵이 가능함. 해당환경에선 Pop, empty체크자 제대로 된다고 볼 수 없음.
게임에선 Try Catch를 잘 안씀-> 어차피 다른곳에서도 문제가 있을 수 있기때문에 강제로 살리는 것보다 보수하는데 효과적임.

 공유데이터와 관련된 문제가 멀티쓰레드에서 자주 발생함.
 스택영역에 있는 데이터는 쓰레드들끼리 공유를 안하지만, 힙영역에 있으면 전역변수는공유해서 사용함.

Atomic : 멀티 스레드 환경에서 안전하게 사용가능한 변수. Lock에 주로 사용한다.

기본적인 STL자료구조들은(vector,map) 멀티스레드에서 정상적으로 동작 안한다고 생각해야한다.
RAII (Resoure Acquisition Is Initialization)  생성자에서 막고, 소멸자에서 풀어줌.
Spin Lock: 하염없이 기다린, 한번에 삭제는 슬립
락을 사용하는것도 중요하지만 올바르게 사용,설치흫 권장해야함

이벤트 : 쓰레드 동기화에 사용. 교착상태에 빠졌을때 다른 한쪽에다가 대기시키는것 , 이벤트는 커널오브젝트라고도 함.
시그널,논시그널 나뉘어져서 상태를 표현해줌. 무의미한 대기를 방지 -> 타프로그램이랑 동기화 때 사용 (WaitForSingleObject)
 
 Condition Variable
커널오븍젝트가 아니라 유저오브젝트임. 물론 내부적으로는 이벤트랑 동일 (타프로그램이랑은 동기화 불가)(condition_variable cv)
 cv.wait(lock,[]() {return q.empty() == false;}  락조건을 걸어줌.)'

Future 
#include<future> 동기 방식의 호출 원래는 끝난시점에서 호출하지만, Future는 비동기방식으로 호출함. -> 실무에서 데이터 로드 부분에서 적용을 해보았었음.
 -> 언젠가 미래의 결과물을 미리 받을것 이라는 방식!!! 
std::packeaged_task<int64<void> task(Calulate);
 1회성으로 다른 스레드에다가 작업을 시킨다고 생각하면 된다!
1) async : 원하는 함수를 비동기적으로 실행
2) promise : 결과물을 나중에 받아서 사용
3) packeged_task : 원하는 함수의 실행 결과를 나중에 받음.



캐시 철학
 1. Temporal Locality : 시간적 순서에 맞춰 먼저 요청에 응답을 먼저줌.
 2. Spatial Locality : 시간적 순서보다는 공간적 위치 중요도에 따른 응답을 고려해 순서를 정한다.

CPU 파이프라인
 여러 쓰레드가 동일한 메모리에 동시 접근, 그 중 하나는 Write연산
 경헙조건이 발생
 Undefined Behavior(정의되지 않은 행동)
  - Lock을 이용한 상호 베타적 접근
  - Atomic(원자적) 연산을 이용

메모리 모델(Memory Model)
 Atomic 연산에 한해, 모든 쓰레드가 동일 객체에 대해서 동일한 수정 순서를 관찰
 원자적 연산, 모든 쓰레드가 동일 객체에 대해서 동일한 수정 순서를 관찰


TLS (Thread Local Storage)
쓰레드별로 일량이 적절하게 배분이 되었는지, 경합이 발생할 경우 무조건 하나의 쓰레드만 일한다.
쓰레드마다 독립된 공간으로 사용하는방법. -> 큰데이터를 미리 할당해서 점해둔 뒤에 운용
//thread_local int 변수 앞에 붙히면 해당 변수는 해당 쓰레드의 변수로만 사용

Lock-Free Stack
 STL컨테이너등에서 데이터를 꺼내거나 넣을때 Lock을 사용하지 않고 쓰레드를 간리하는 기법, Pop부분에서 헤드를 바꿔줄때 다른 스레드에서 접근하면 문제가 발생한다. 검증된 컨테이너만 사용하는게 좋다. 안정성이 아직은 많이 힘들다.
