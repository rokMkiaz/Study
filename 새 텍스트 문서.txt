//Atomic : 멀티 스레드 환경에서 안전하게 사용가능한 변수. Lock에 주로 사용한다.

//기본적인 STL자료구조들은(vector,map) 멀티스레드에서 정상적으로 동작 안한다고 생각해야한다.
//RAII (Resoure Acquisition Is Initialization)  생성자에서 막고, 소멸자에서 풀어줌.
//Spin Lock: 하염없이 기다린, 한번에 삭제는 슬립
//락을 사용하는것도 중요하지만 올바르게 사용,설치흫 권장해야함
//
//이벤트 : 쓰레드 동기화에 사용. 교착상태에 빠졌을때 다른 한쪽에다가 대기시키는것 , 이벤트는 커널오브젝트라고도 함.
//시그널,논시그널 나뉘어져서 상태를 표현해줌. 무의미한 대기를 방지 -> 타프로그램이랑 동기화 때 사용 (WaitForSingleObject)
// 
// Condition Variable
//커널오븍젝트가 아니라 유저오브젝트임. 물론 내부적으로는 이벤트랑 동일 (타프로그램이랑은 동기화 불가)(condition_variable cv)
// cv.wait(lock,[]() {return q.empty() == false;}  락조건을 걸어줌.)'
//
//Future 
//#include<future> 동기 방식의 호출 원래는 끝난시점에서 호출하지만, Future는 비동기방식으로 호출함. -> 실무에서 데이터 로드 부분에서 적용을 해보았었음.
// -> 언젠가 미래의 결과물을 미리 받을것 이라는 방식!!! 
//std::packeaged_task<int64<void> task(Calulate);
// 1회성으로 다른 스레드에다가 작업을 시킨다고 생각하면 된다!
//1) async : 원하는 함수를 비동기적으로 실행
//2) promise : 결과물을 나중에 받아서 사용
//3) packeged_task : 원하는 함수의 실행 결과를 나중에 받음.
