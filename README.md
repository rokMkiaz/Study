운영체제

프로세스  vs 스레드 모델 :
프로세스는 독립적인 메모리 공간(코드,데이터,힙,스텍 등)을 가집니다.
문맥 전환시 페이지 테이블등 메모리 매핑 정보를 저장 복원해야 하므로 비용이 큼.
스레드는 같은 프로세스 내에서 메모리를 공유하며, 자체 스택과 레지스터만 저장하므로 비용이 적음.

컨텍스트 스위칭 비용 : 
프로세스 간 전환은 페이지 테이블과 주소 공간을 교체해야 하므로 비용이 크고, 
스레드 간 전환은 스택포인터와 레지스터만 저장 복원하면 되어 비용이 작음.

가상 메모리 동작 원리 :
가상 메모리는 페이지 단위로 관리되며, 페이지 테이블을 통해 가상 주소와 물리 주소를 매핑,
TLB는 페이지 테이블 엔트리를 캐싱하여 주소 변환 속도를 높임.

페이지 교체 알고리즘 :
 - LRU(Least Recently Used) :  가장 오랫동안 참조되지 않은 주기억장치 페이지 교체
 - FIFO(First In First Out) : 가장 오래전에 적제된 페이지 교체
 - Clock : 각 프레임에 대해 사용비트 연계 페이지 프레임을 하나의 원으로 배치+포인터를 시계바늘로 배치
TLB(Translation Lookaside Buffer)
CPU 내부 캐시로, 최근 사용된 페이지 테이블 엔트리를 저장하여 주소 변환 시간을 단축합니다.

동기화 기법:
뮤텍스 : 한 번에 하나의 스레든만 임계 구역에 접근하도록 상호배제
세마포어: 정수 카운터를 사용해 여러 스레드가 동시 접근을 제어.
스핀락 : 잠금을 얻을 때 까지 대기 방식으로 반복대기

네트워크
CSI 7계층 구조와 역할
1. 물리계층 : 전기적, 기계적 신호 전송.
2. 데이터 링크 계층: 프레임 전송, MAC 주소 사용.
3. 네트워크 계층 : 패킷 라우팅, IP주소 사용.
4. 전송 계층 : TCP/UDP 통한 종단 간 연결 및 제어
5. 세션 계층 : 통신 세션 설정 유지 해제
6. 표현 계층 : 데이터 형식 변환(암호화,압축)
7. 응용 계층 : HTTP, FTP, SMP 등 애플리케이션 프로토콜

TCP vs UDP 및 3-Handshake:
TCP : 연결 지향, 신뢰성 제공, 흐름제어 및 혼잡 제어 포함.
UDP : 비연결형, 헤더 오버헤드 작고 지연 시간 짧지만 신뢰성 미제공.
3-way Handshake : SYN+ACK -> ACK 과정을 통해 연결 수립

HTTP 요청 / 응답 흐름 :
클라이언트가 서버에 요청 헤더와 바디를 보내고, 서버는 상태코드
응답헤더, 바디를 포함한 응답을 반환

REST API 통신 절차 :
GET, POST, PUT/PATCH, DELETE등 HTTP 메소드로 자원을 조작하며, JSON XML 등 형식을 통해 요청과 응답을 교환

DataBase
정규화 :
데이터 중복 최소화 및 이상현상 방지를 위해 테이블을 분해하는 과정.
장점 : 데이터 무결성, 저장 공간 절약, 이상현상 방지.
단점 : JOIN 증가로 쿼리 성능 저하, 설계 복잡도 증가.

인덱스 구조(B-Tree vs Hash):
B-Tree : 균형 트리 구조로 범위 검색에 유리, 정렬된 데이터 저장
Hash : 해시 테이블 기반으로 동등 비교에 빠르지만 범위 검색 부적합.
인덱스는 검색 속도를 높이지만 삽입/ 삭제 시 비용 발생 및 추가 저장 공간 필요.

트랜잭션 격리 수준:
1) Read Uncommitted: Dirty Read 허용.
2) Read Committed: 커밋된 데이터만 읽음, Non-Repeatable Read 발생 가능.
3) Repeatable Read: 같은 쿼리 결과 일관성, Phantom Read 발생 가능.
4) Serializable: 모든 이상현상 방지하지만 동시성 저하 가능.

쿼리 최적화 병목 이슈:
인덱스 미사용으로 인한 전체 테이블 스캔, 과도한 JOIN, 서브쿼리 비효율, 
통계 정보 부정확, 데이터 분포 불균형 등이 주요 원인

자료구조 
리스트(List): 배열 또는 연결 리스트로 구현. 탐색 O(n), 배열 삽입/삭제 O(n),
스택(Stack): FILO, 삽입/삭제 O(1).
큐(Queue): FIFO, 삽입/삭제 O(1).
힙(Heap): 우선순위 큐, 삽입/삭제 O(log n), 탐색(루트) O(1).
그래프(Graph): 정점과 간선, 인접 리스트/인접 행렬로 표현.
해시 테이블(Hash Table): 평균 탐색/삽입/삭제 O(1), 최악 O(n).

시간 복잡도:
배열: 탐색 O(n), 인덱스 접근 O(1), 삽입/삭제 O(n)
연결 리스트: 탐색 O(n), 삽입/삭제 O(1) (노드 참조 시)
BST: 평균 O(log n), 최악 O(n)
힙: 삽입/삭제 O(log n), 탐색(루트) O(1)

트리 순회 및 MST:
전위 순회: 루트→왼쪽→오른쪽,
중위 순회: 왼쪽→루트→오른쪽,
후위 순회: 왼쪽→오른쪽→루트.
최소 신장 트리(MST): 가중치 합 최소 그래프 트리, Kruskal, Prim 알고리즘 사용.

컴퓨터 구조/시스템 기초
파이프라이닝 vs 슈퍼스칼라:
파이프라이닝: 명령어 처리를 여러 단계로 분할해 병렬 처리, 처리량 증가.
슈퍼스칼라: 한 사이클에 여러 명령어 동시 실행, 실행 유닛 복수 사용.
캐시 메모리 및 캐시 일관성:
L1, L2, L3 계층으로 구성, L1이 가장 빠름.
멀티코어 환경에서 동일 데이터 캐시 시 캐시 일관성 유지 위해 MESI 등 프로토콜 사용.
ISA vs 마이크로아키텍처:
ISA: 프로그래머가 인식하는 명령어와 레지스터, 메모리 모델 정의.
마이크로아키텍처: ISA를 구현하기 위한 내부 구조(파이프라인, 캐시, 분기 예측 등).

기타
동시성 vs 병렬성:
동시성(Concurrency): 여러 작업이 시간상 겹쳐 실행되는 것처럼 보임, 단일 CPU에서도 가능.
병렬성(Parallelism): 여러 작업이 실제로 동시에 실행, 멀티코어/분산 시스템 필요.
로드 밸런싱 & 세션 관리:
로드 밸런싱: 요청을 여러 서버에 분산해 처리량과 가용성 향상(라운드 로빈, 최소 연결, IP 해시 등).세션 관리: 사용자의 상태 유지(로그인, 장바구니 등) 위해 서버 메모리, 데이터베이스, 분산 캐시 사용스케일링(Scale-up vs Scale-out):
Scale-up: 기존 서버 CPU, 메모리 업그레이드, 적용 쉬우나 한계 존재.
Scale-out: 서버 인스턴스 추가해 클러스터 구성, 뛰어난 확장성, 분산 환경에서 데이터 일관성 고려 



시험문제 반성

 RTT는 Round Trip Time의 약자로, 
네트워크 신호가 한 지점에서 다른 지점으로 갔다가 다시 돌아오는 데 걸리는 시간을 의미합니다. 주로 밀리초 단위로 측정되며,
네트워크 성능을 나타내는 중요한 지표입니다. RTT는 네트워크의 연결 상태, 속도, 안정성 등을 평가하는 데 사용됩니다. 

TLS란?
 TLS는 쓰레드가 각각 가지고 있는 저장소이다.
이 곳에 저장되는 값들은 전역변수 이지만, 한 쓰레드 내에서만 유효한 전역 변수이다. 이러한 면에서 Stack과는 차이가 있다.
그래서 이 TLS을 이용해서 쓰레드가 집중된 task를 빠르게 처리하는가? 하면, 공유하는 영역인 Heap,
데이터 영역의 값을 사용 할 만큼 큼직하게 잘라서 TLS로 가져온다. 이 과정만 하기 때문에 부하가 크지는 않을 것이다.
이렇게 공유영역에서 가져온 값을 TLS로 옮기면 그 이후에 mutex를 차지하기 위한 경합이 일어나지 않을 것이다.

MTU (Maximum Transmission Unit)는 네트워크에서 전송할 수 있는 최대 데이터 패킷 크기를 의미합니다. 
즉, 하나의 네트워크에서 전송할 수 있는 데이터의 최대 바이트 수입니다. 
보통 IP 헤더, TCP 헤더, 페이로드를 모두 포함하여 측정하며, 이더넷의 경우 기본적으로 1500바이트를 사용합니다.
MTU는 네트워크 장치나 링크의 특성에 따라 달라질 수 있으며, MTU보다 큰 패킷은 네트워크를 통과하지 못하고 분할되어야 합니다. 
